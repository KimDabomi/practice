{"ast":null,"code":"import { css as n } from \"styled-components\";\nvar e = {\n    mobile: 0,\n    tablet: 737,\n    desktop: 1195\n  },\n  t = function (n) {\n    return n / 16;\n  },\n  r = Object.freeze([\"\\n          @media screen and (min-width: \", \"em) {\\n            \", \"\\n          }\\n        \"]),\n  o = Object.freeze([\"\\n        @media screen and (min-width: \", \"em) and (max-width: \", \"em) {\\n          \", \"\\n        }\\n      \"]),\n  i = function (n, e) {\n    return e in n ? n[e] : (console.error('styled-components-breakpoint: Breakpoint \"' + e + '\" was not found.'), 0);\n  },\n  a = function (e) {\n    return function (a, c) {\n      return function (u) {\n        for (var f = [], s = arguments.length - 1; s-- > 0;) f[s] = arguments[s + 1];\n        if (a && c) {\n          var p = i(e, a),\n            d = i(e, c);\n          return n(o, t(p), t(d - 1), n.apply(void 0, [u].concat(f)));\n        }\n        var y = i(e, a);\n        return 0 === y ? n.apply(void 0, [u].concat(f)) : n(r, t(y), n.apply(void 0, [u].concat(f)));\n      };\n    };\n  },\n  c = function (n, t) {\n    return function (r) {\n      for (var o = [], i = arguments.length - 1; i-- > 0;) o[i] = arguments[i + 1];\n      return function (i) {\n        return a((c = i.theme) && c.breakpoints ? c.breakpoints : e)(n, t)(r, o);\n        var c;\n      };\n    };\n  },\n  u = function (n, e) {\n    var t = Object.keys(n),\n      r = -1;\n    Object.keys(e).some(function (n) {\n      var o = t.indexOf(n);\n      return -1 !== o && o <= r ? (console.warn(\"styled-components-breakpoint: Values for \" + JSON.stringify(e) + \" are not keyed in order (\" + t.map(function (n) {\n        return '\"' + n + '\"';\n      }).join(\", \") + \") and may result in specificity issues.\"), !0) : (r = o, !1);\n    });\n  };\nfunction f(e, t, r, o) {\n  var i = a(e);\n  if (\"object\" != typeof t) {\n    var c = r(t);\n    return \"string\" == typeof c || Array.isArray(c) ? c : n(c);\n  }\n  return \"production\" !== process.env.NODE_ENV && u(e, t), Object.keys(t).map(function (n) {\n    var e = i(n),\n      a = t[n];\n    if (void 0 === a) return \"\";\n    var c = r(a, o);\n    return \"string\" == typeof c || Array.isArray(c) ? e([], c) : e(c);\n  });\n}\nvar s = function (n) {\n    return function (e, t, r) {\n      return \"object\" != typeof n || \"object\" != typeof r ? function (o) {\n        var i = \"object\" != typeof n ? n(o.theme) : n,\n          a = void 0 !== r && \"object\" != typeof r ? r(o.theme) : r;\n        return f(i, e, t, a);\n      } : f(n, e, t, r);\n    };\n  },\n  p = s(function (n) {\n    return n.breakpoints || e;\n  });\nexport default c;\nexport { e as defaults, a as createBreakpoint, c as breakpoint, s as createMap, p as map };","map":{"version":3,"mappings":";IAEaA,IAAiD;IAE5DC,QAAQ;IAGRC,QAAQ;IAGRC,SAAS;EAAA;ECTEC,cAAiBC;IAAAA,OAA2BA,IAAS;EAAA;EAAAC;EAAAC;ECO5DC,cACJC,GACAC;IAAAA,OAEMA,KAAcD,IAMbA,EAAYC,MALjBC,QAAQC,qDACuCF,yBAExC;EAAA;EAKEG,cACXJ;IAAAA,iBAC2BK,GAAaC;MAAAA,iBAEhCC;QAAAA;QAAAA,IAEFF,KAAeC,GAAa;UAAA,IACxBE,IAAUT,EAAkBC,GAAaK;YACzCI,IAAUV,EAAkBC,GAAaM;UAAAA,OACxCI,KAC2Bf,EAC5Ba,IACsBb,EAAcc,IAAU,IAC9CC,iBAAIH,UAAYI;QAAAA;QAAAA,IAIhBH,IAAUT,EAAkBC,GAAaK;QAAAA,OAC/B,MAAZG,IACKE,iBAAIH,UAAYI,MAEhBD,KAC2Bf,EAAca,IAC1CE,iBAAIH,UAAYI;MAAAA;IAAAA;EAAAA;ECzBjBV,cACXI,GACAC;IAAAA,iBAGQC;MAAAA;MAAAA,iBAEoBK;QAAAA,OACjBR,OACmBQ,YAZrBC,EAAMb,cAAca,EAAMb,cAAeT,EAWvCa,CAELC,GAAaC,EAFRF,CAEqBG,GAASI;QAAAA;MAAAA;IAAAA;EAAAA;EChBrCG,cAIJd,GACAe;IAAAA,IAEMC,IAAiBC,OAAOC,KAAKlB;MAC/BmB,KAAiB;IACrBF,OAAOC,KAAKH,GAAQK,eAAKC;MAAAA,IACjBC,IAAQN,EAAeO,QAAQF;MAAAA,QACtB,MAAXC,KAAgBA,KAASH,KAC3BjB,QAAQsB,mDACsCC,KAAKC,UAC/CX,mCAC2BC,EAC1BW,cAAIC;QAAAA,aAASA;MAAAA,GACbC,KAAK,qDAEH,MAEPV,IAAgBG,IACT;IAAA;EAAA;AAKb,SAASK,EAKP3B,GACA8B,GACAC,GACAC;EAAAA,IAEMC,IAAK7B,EAAoBJ;EAAAA,IAEF,mBAAlB8B,GAA4B;IAAA,IAC/BI,IAAQH,EAAgBD;IAAAA,OAEN,mBAAVI,KAAsBC,MAAMC,QAAQF,KAC9CA,IACAxB,EAAIwB;EAAAA;EAAAA,OAImB,iBAAzBG,QAAQC,IAAIC,YACdzB,EAAoBd,GAAa8B,IAItBb,OAAOC,KAAKY,GACbH,cAAKa;IAAAA,IACTC,IAAMR,EAAGO;MAETE,IAAqBZ,EAAcU;IAAAA,SAC7BG,MAARD,GAAmB,OAAO;IAAA,IACxBR,IAAQH,EAAgBW,GAAKV;IAAAA,OACd,mBAAVE,KAAsBC,MAAMC,QAAQF,KAGtCO,EAAI,IAAIP,KAIRO,EAAIP;EAAAA;AAAAA;AAAAA,IAMJU,cACX5C;IAAAA,iBAGE8B,GACAC,GACAC;MAAAA,OAE2B,mBAAhBhC,KAA6C,mBAAVgC,cACjCpB;QAAAA,IACHiC,IACmB,mBAAhB7C,IACHA,EAAYY,EAAMC,SAClBb;UACA8C,SACMH,MAAVX,KAAwC,mBAAVA,IAC1BA,EAAMpB,EAAMC,SACZmB;QAAAA,OACCL,EAAIkB,GAAGf,GAAeC,GAAiBe;MAAAA,IAGzCnB,EAAI3B,GAAa8B,GAAeC,GAAiBC;IAAAA;EAAAA;ECtGjDL,IAAMiB,YACjB/B;IAAAA,OAAUA,EAAcb,eAAeT;EAAAA;AAAAA;AAAAA","names":["defaults","mobile","tablet","desktop","convertPxToEm","pixels","r","o","getBreakpointSize","breakpoints","breakpoint","console","error","createBreakpoint","breakpointA","breakpointB","strings","pixelsA","pixelsB","css","interpolations","props","theme","checkValuesOrdering","values","breakpointKeys","Object","keys","previousIndex","some","k","index","indexOf","warn","JSON","stringify","map","n","join","valueOrValues","mapValueToStyle","scale","fn","style","Array","isArray","process","env","NODE_ENV","key","tag","val","undefined","createMap","b","s"],"sources":["C:\\Users\\cdabo\\react\\05-stylesheet\\node_modules\\styled-components-breakpoint\\src\\defaults.ts","C:\\Users\\cdabo\\react\\05-stylesheet\\node_modules\\styled-components-breakpoint\\src\\convertPxToEm.ts","C:\\Users\\cdabo\\react\\05-stylesheet\\node_modules\\styled-components-breakpoint\\src\\createBreakpoint.ts","C:\\Users\\cdabo\\react\\05-stylesheet\\node_modules\\styled-components-breakpoint\\src\\breakpoint.ts","C:\\Users\\cdabo\\react\\05-stylesheet\\node_modules\\styled-components-breakpoint\\src\\createMap.ts","C:\\Users\\cdabo\\react\\05-stylesheet\\node_modules\\styled-components-breakpoint\\src\\map.ts"],"sourcesContent":["import {BreakpointMap, DefaultBreakpointName} from './types';\n\nexport const defaults: BreakpointMap<DefaultBreakpointName> = {\n  // targeting all devices\n  mobile: 0,\n\n  // targeting devices that are LARGER than the iPhone 6 Plus (which is 736px in landscape mode)\n  tablet: 737,\n\n  // targeting devices that are LARGER than the 11\" iPad Pro (which is 1194px in landscape mode)\n  desktop: 1195,\n};\n","// @media is always calculated off 16px regardless of whether the root font size is the default or not\nexport const convertPxToEm = (pixels: number): number => pixels / 16;\n","import {css} from 'styled-components';\nimport {\n  BreakpointMap,\n  BreakpointNameConstraint,\n  BreakpointFunction,\n} from './types';\nimport {convertPxToEm} from './convertPxToEm';\n\nconst getBreakpointSize = <B extends BreakpointNameConstraint>(\n  breakpoints: BreakpointMap<B>,\n  breakpoint: B,\n): number => {\n  if (!(breakpoint in breakpoints)) {\n    console.error(\n      `styled-components-breakpoint: Breakpoint \"${breakpoint}\" was not found.`,\n    );\n    return 0;\n  }\n  return breakpoints[breakpoint];\n};\n\nexport const createBreakpoint = <B extends BreakpointNameConstraint>(\n  breakpoints: BreakpointMap<B>,\n): BreakpointFunction<B> => (breakpointA, breakpointB) => {\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  return (strings: any, ...interpolations: any[]) => {\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n    if (breakpointA && breakpointB) {\n      const pixelsA = getBreakpointSize(breakpoints, breakpointA);\n      const pixelsB = getBreakpointSize(breakpoints, breakpointB);\n      return css`\n        @media screen and (min-width: ${convertPxToEm(\n            pixelsA,\n          )}em) and (max-width: ${convertPxToEm(pixelsB - 1)}em) {\n          ${css(strings, ...interpolations)}\n        }\n      `;\n    } else {\n      const pixelsA = getBreakpointSize(breakpoints, breakpointA);\n      if (pixelsA === 0) {\n        return css(strings, ...interpolations);\n      } else {\n        return css`\n          @media screen and (min-width: ${convertPxToEm(pixelsA)}em) {\n            ${css(strings, ...interpolations)}\n          }\n        `;\n      }\n    }\n  };\n};\n","import {StyledProps, css} from 'styled-components';\nimport {ThemedBreakpointName, BreakpointMap} from './types';\nimport {defaults} from './defaults';\nimport {createBreakpoint} from './createBreakpoint';\n\ntype CSSFunction = (\n  ...params: Parameters<typeof css>\n) => <P extends object>({theme}: StyledProps<P>) => ReturnType<typeof css>;\n\ntype ThemedBreakpointMap = BreakpointMap<ThemedBreakpointName>;\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n// casting because we can't really do anything better when the theme is defined but no theme values are defined\nconst getBreakpointsFromTheme = <P extends object>({\n  theme,\n}: StyledProps<P>): ThemedBreakpointMap =>\n  theme && theme.breakpoints ? theme.breakpoints : (defaults as any);\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nexport const breakpoint = (\n  breakpointA: ThemedBreakpointName,\n  breakpointB?: ThemedBreakpointName,\n): CSSFunction => {\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  return (strings: any, ...interpolations: any[]) => {\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n    return <P extends object>(props: StyledProps<P>) => {\n      return createBreakpoint<ThemedBreakpointName>(\n        getBreakpointsFromTheme(props),\n      )(breakpointA, breakpointB)(strings, interpolations);\n    };\n  };\n};\n","import {\n  BreakpointMap,\n  ValueOrValueMap,\n  BreakpointNameConstraint,\n  ValueConstraint,\n  ValueToStyleFunction,\n  ScaleConstraint,\n  MapFunction,\n} from './types';\nimport {createBreakpoint} from './createBreakpoint';\nimport {css, CSSObject, StyledProps, DefaultTheme} from 'styled-components';\n\n// ensure the values are keyed in breakpoint order, otherwise specificity issues may occur\nconst checkValuesOrdering = <\n  B extends BreakpointNameConstraint,\n  V extends ValueConstraint\n>(\n  breakpoints: BreakpointMap<B>,\n  values: ValueOrValueMap<B, V>,\n): void => {\n  const breakpointKeys = Object.keys(breakpoints);\n  let previousIndex = -1;\n  Object.keys(values).some(k => {\n    const index = breakpointKeys.indexOf(k);\n    if (index !== -1 && index <= previousIndex) {\n      console.warn(\n        `styled-components-breakpoint: Values for ${JSON.stringify(\n          values,\n        )} are not keyed in order (${breakpointKeys\n          .map(n => `\"${n}\"`)\n          .join(', ')}) and may result in specificity issues.`,\n      );\n      return true;\n    } else {\n      previousIndex = index;\n      return false;\n    }\n  });\n};\n\nfunction map<\n  B extends BreakpointNameConstraint,\n  V extends ValueConstraint,\n  S extends ScaleConstraint\n>(\n  breakpoints: BreakpointMap<B>,\n  valueOrValues: ValueOrValueMap<B, V>,\n  mapValueToStyle: ValueToStyleFunction<V, S>,\n  scale?: S,\n): string | ReturnType<typeof css> {\n  const fn = createBreakpoint<B>(breakpoints);\n\n  if (typeof valueOrValues !== 'object') {\n    const style = mapValueToStyle(valueOrValues);\n    // @see https://github.com/microsoft/TypeScript/issues/17002\n    return typeof style === 'string' || Array.isArray(style)\n      ? style\n      : css(style as CSSObject);\n  }\n\n  // check the ordering of breakpoints\n  if (process.env.NODE_ENV !== 'production') {\n    checkValuesOrdering(breakpoints, valueOrValues);\n  }\n\n  // map the value at each breakpoint to styles\n  const keys = Object.keys(valueOrValues) as B[];\n  return keys.map((key: B) => {\n    const tag = fn(key);\n    // FIXME: not sure why the type isn't correctly inferred here\n    const val: V | undefined = valueOrValues[key];\n    if (val === undefined) return '';\n    const style = mapValueToStyle(val, scale);\n    if (typeof style === 'string' || Array.isArray(style)) {\n      /* eslint-disable @typescript-eslint/ban-ts-ignore */\n      // @ts-ignore - ignore inability to create a real TemplateStringsArray\n      return tag([], style);\n      /* eslint-enable @typescript-eslint/ban-ts-ignore */\n    } else {\n      // @see https://github.com/microsoft/TypeScript/issues/17002\n      return tag(style as CSSObject);\n    }\n  });\n}\n\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\nexport const createMap = <B extends BreakpointNameConstraint>(\n  breakpoints: BreakpointMap<B> | ((theme: DefaultTheme) => BreakpointMap<B>),\n): MapFunction<B> => {\n  return <V extends ValueConstraint, S extends ScaleConstraint>(\n    valueOrValues: ValueOrValueMap<B, V>,\n    mapValueToStyle: ValueToStyleFunction<V, S>,\n    scale?: S | ((theme: DefaultTheme) => S),\n  ) => {\n    if (typeof breakpoints !== 'object' || typeof scale !== 'object') {\n      return <P>(props: StyledProps<P>) => {\n        const b =\n          typeof breakpoints !== 'object'\n            ? breakpoints(props.theme)\n            : breakpoints;\n        const s =\n          scale !== undefined && typeof scale !== 'object'\n            ? scale(props.theme)\n            : scale;\n        return map(b, valueOrValues, mapValueToStyle, s);\n      };\n    } else {\n      return map(breakpoints, valueOrValues, mapValueToStyle, scale);\n    }\n  };\n};\n/* eslint-enable @typescript-eslint/explicit-function-return-type */\n","import 'styled-components';\nimport {defaults} from './defaults';\nimport {createMap} from './createMap';\nimport {ThemedBreakpointName} from './types';\n\nexport const map = createMap<ThemedBreakpointName>(\n  theme => (theme as any).breakpoints || defaults,\n);\n"]},"metadata":{},"sourceType":"module"}